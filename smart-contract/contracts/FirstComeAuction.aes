contract FirstComeAuction =

  record state = { available_time: int, owner: address, bids: list(bid) }
  record point = { x: int, y: int }
  record bid = { sender: address, hash: string, point: point, time: int, amount: int }

  private function require(b : bool, err : string) =
    if(!b) abort(err)

  // thanks hans
  function filter(f : ('a) => bool, l : list('a), acc : list('a)) =
    switch(l)
      [] => acc
      e :: l' =>
        if(f(e))
          filter(f, l', e :: acc)
        else
          filter(f, l', acc)

  public function init(available_time): state = { available_time = available_time, owner = Call.caller, bids = [] }

  public stateful function bid(hash: string, x: int, y: int, time: int) =
    let remaining_time = state.available_time - time
    require(remaining_time >= 0, "Less time available then bid for")
    let point = { x = x, y = y }
    let bid = { sender = Call.caller, hash = hash, point = point, time = time, amount = Call.value }
    put(state{ bids = bid :: state.bids, available_time = remaining_time })

  public function all_bids() =
    state.bids

  public function my_bids() =
    let predicate = (x_bid) => x_bid.sender == Call.caller
    filter(predicate, state.bids, [])

  public function available_time() =
    state.available_time

  public function owner_withdraw() =
    require(Call.caller == state.owner, "Only owner can withdraw")
    Chain.spend(state.owner, Contract.balance)
