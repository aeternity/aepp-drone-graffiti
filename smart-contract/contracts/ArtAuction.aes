contract ArtAuction =

  type is_admin = map(address, bool)

  type auction_slots = map(int, auction_slot)

  record state =
    { is_admin : is_admin
    , latest_auction_slot_id : int
    , auction_slots : auction_slots }

  record auction_slot =
    { id : int
    , time_capacity : int
    , minimum_time_per_bid : int
    , maximum_time_per_bid : int
    , successful_bids : list(bid)
    , failed_bids : list(bid)
    , start_block_height : int
    , end_block_height : int }

  record bid =
    { user : address
    , amount : int
    , time : int
    , data : artwork_data }

  record artwork_data =
    { artwork_reference : string
    , coordinates : coordinates }

  record coordinates =
    { x : int
    , y : int }

  public function init() : state =
    { is_admin = {[Call.caller] = true},
      latest_auction_slot_id = 0,
      auction_slots = {} }

  public stateful function add_auction_slot(time_capacity' : int,
                                            start_block_height' : int,
                                            block_duration : int,
                                            minimum_time_per_bid' : int,
                                            maximum_time_per_bid' : int) : int =
    require(is_admin(Call.caller), "add_auction_slot caller has to be admin")
    require(in_future(start_block_height'), "add_auction_slot start_block_height' has to be in future")
    require(is_greater_zero(time_capacity'), "add_auction_slot time_capacity' has to be greater than 0")
    require(is_greater_zero(block_duration), "add_auction_slot block_duration has to be greater than 0")
    require(is_greater_zero(minimum_time_per_bid'), "add_auction_slot minimum_time_per_bid' has to be greater than 0")
    require(is_greater_zero(maximum_time_per_bid'), "add_auction_slot maximum_time_per_bid' has to be greater than 0")

    let next_auction_slot_id = state.latest_auction_slot_id + 1

    let new_auction_slot = { id = next_auction_slot_id,
                             time_capacity = time_capacity',
                             minimum_time_per_bid = minimum_time_per_bid',
                             maximum_time_per_bid = maximum_time_per_bid',
                             successful_bids = [],
                             failed_bids = [],
                             start_block_height = start_block_height',
                             end_block_height = start_block_height' + block_duration }

    put(state{ latest_auction_slot_id = next_auction_slot_id, auction_slots[next_auction_slot_id] = new_auction_slot })
    next_auction_slot_id

  public function all_auction_slots() : list(auction_slot) =
    let auction_slot_list = Map.to_list(state.auction_slots)
    map(tuple_second, auction_slot_list)

  public function get_auction_slot(id : int) : auction_slot =
    switch(Map.lookup(id, state.auction_slots))
      Some(auction_slot) => auction_slot
      None => abort("auction_slot does not exist")

  // TODO: check canvas size
  public stateful function place_bid(auction_slot_id : int,
                                     time' : int,
                                     artwork_reference' : string,
                                     x' : int,
                                     y' : int) =
    require(is_greater_zero(Call.value), "place_bid call value has to be greater than 0")
    let auction_slot = get_auction_slot(auction_slot_id)
    require(auction_slot.time_capacity >= time', "place_bid time_capacity of auction_slot has to be greater or equals time bid for")
    require(auction_slot.start_block_height < Chain.block_height, "place_bid auction_slot is not yet opened at height")
    require(auction_slot.end_block_height > Chain.block_height, "place_bid auction_slot is already closed at height")
    require(auction_slot.minimum_time_per_bid =< time', "place_bid time has to be greater or equals auction_slot minimum_time_per_bid")
    require(auction_slot.maximum_time_per_bid >= time', "place_bid time has to be smaller or equals auction_slot maximum_time_per_bid")

    let coordinates' = { x = x', y = y' }
    let artwork_data' = { artwork_reference = artwork_reference', coordinates = coordinates' }
    let bid = { user = Call.caller,
                amount = Call.value,
                time = time',
                data = artwork_data' }

    // only reprocesses previously successful bids plus the new one, returned bids are old successful, excluding old failed
    let bids_to_reprocess = insert_by(bid_amount_comperator, bid, auction_slot.successful_bids)

    // TODO: use actual amount per time here!
    let split_successful_bids_tuple = process_bids(auction_slot.time_capacity, bids_to_reprocess)

    //old failed bids have to be appended to newly failed bids from reprocessing, successful includes all old ones
    let updated_auction_slot = update_auction_slot_with_bids(auction_slot, split_successful_bids_tuple)

    put(state{ auction_slots[auction_slot_id] = updated_auction_slot })
    refund_new_to_low_bids(split_successful_bids_tuple)
    updated_auction_slot


  public stateful function admin_withdraw() =
    require(is_admin(Call.caller), "admin_withdraw caller has to be admin")
    let balance_to_withdraw = Contract.balance
    Chain.spend(Call.caller, balance_to_withdraw)
    balance_to_withdraw


  // internal functions //

  private stateful function refund_new_to_low_bids(bids_tuple : (list(bid), list(bid))) =
    switch(bids_tuple)
      (_, new_failed_bids) =>
        let refund_function = (bid : bid) => Chain.spend(bid.user, bid.amount)
        map(refund_function, new_failed_bids)

  private function update_auction_slot_with_bids(auction_slot : auction_slot, bids_tuple : (list(bid), list(bid))) : auction_slot =
    switch(bids_tuple)
      (all_successful_bids, new_failed_bids) =>
        let appended_failed_bids = new_failed_bids ++ auction_slot.failed_bids
        auction_slot{ successful_bids = all_successful_bids, failed_bids = appended_failed_bids }

  private function process_bids(time_capacity : int, bids_to_reprocess : list(bid)) : (list(bid), list(bid)) =
      let filter_by_capacity = (bid : bid, acc_bids) =>
        switch(acc_bids)
         (sufficient, to_low) =>
           if(time_capacity >= sum(sufficient, (x) => x.time) + bid.time)
             (bid :: sufficient, to_low)
           else
             (sufficient, bid :: to_low)
      foldr(filter_by_capacity, ([], []), bids_to_reprocess)

  private function bid_amount_comperator(a : bid, b : bid) = a.amount > b.amount

  private function tuple_second(tuple) =
    switch(tuple)
      (_, e) => e

  private function in_future(height : int) : bool =
    height > Chain.block_height

  private function is_admin(address : address) : bool =
    Map.lookup_default(address, state.is_admin, false)


  // general helper functions //

  private function sum(l : list('a), f : 'a => int) : int =
    foldr((x, y) => x + y, 0, map(f, l))

  private function map(f : 'a => 'b, l : list('a)) : list('b) =
    switch(l)
     [] => []
     e :: l' => f(e) :: map(f, l')

  private function foldr(f : (('a, 'b) => 'b), z: 'b, l : list('a)) : 'b =
    switch(l)
      [] => z
      e :: l' => f(e, foldr(f, z, l'))

  private function insert_by(f: (('a, 'a) => bool), x : 'a, l : list('a)) : list('a) =
    switch(l)
      [] => [x]
      (e :: l') =>
        if(f(x, e))
          e :: insert_by(f, x, l')
        else
          x :: l

  private function is_greater_zero(x : int) : bool = x > 0

  private function require(b : bool, err : string) =
    if(!b) abort(err)
